

class KVIdb
{
  constructor ( db_s='kv_db', store_s='kv_store', version=1 )
  {
    this.idb     = null
    this.idb_s   = db_s
    this.store   = store_s
    this.version = version
    this.ready   = null

    this.init()
  }

  init ()
  {
    this.ready = new Promise( ( resolve, reject ) =>
    {
      const request = window.indexedDB.open( this.idb_s, this.version )

      request.onupgradeneeded = req_e => 
      {
        this.idb = req_e.target.result
        this.idb.createObjectStore( this.store )
      }

      request.onsuccess = req_e =>
      {
        this.idb = req_e.target.result
        resolve( req_e.target.result )    //: only to complete because we dont use result but this.idb in transactions
      }

      request.onerror = req_e =>  reject( req_e.target.error )
    })
  }

  get ( key )
  {
    return this.ready
      .then( () => 
      {
        return new Promise( ( resolve, reject ) =>
        {
          const mode = 'readonly'
          const request = this.idb.transaction( [ this.store ], mode ).objectStore( this.store )
            .get( key )

          request.onsuccess = req_e => resolve( req_e.target.result )

          request.onerror = reject
        })
      })
  }


  walk ( callback_f )
  {
    return this.ready
      .then( () => 
      {
        return new Promise( ( resolve, reject ) =>
        {
          const mode = 'readonly'
          const request = this.idb.transaction( [ this.store ], mode ).objectStore( this.store )
            .openCursor()
          request.onsuccess = req_e =>
          {
            let cursor = req_e.target.result
            if ( cursor )
            {
              callback_f( cursor.key, cursor.value )
              cursor.continue()
            }
            else resolve()
          }
  
          request.onerror = reject
        })
      })
  }

  last ()
  {
    return this.ready
      .then( () => 
      {
        return new Promise( ( resolve, reject ) =>
        {
          const mode = 'readonly'
          const request = this.idb.transaction( [ this.store ], mode ).objectStore( this.store )
            .openCursor( null, 'prev' )

          request.onsuccess = req_e =>
          {
            if ( req_e.target.result ) resolve( req_e.target.result.value )
          }

          request.onerror = reject
        })
      })
  }


  set ( key, value )
  {
    return this.ready
      .then( () =>
      {
        return new Promise( ( resolve, reject ) =>
        {
          const mode = 'readwrite'
          const request = this.idb.transaction( [ this.store ], mode ).objectStore( this.store )
            .put( value, key )

          request.onsuccess = resolve    //: nothing to do

          request.onerror = reject
        })
      })
  }

  update ( key, property, value )
  {
    return this.ready
      .then( () =>
      {
        return new Promise( ( resolve, reject ) =>
        {
          const mode = 'readwrite'
          const store = this.idb.transaction( [ this.store ], mode ).objectStore( this.store )
          const getRequest = store.get( key )

          getRequest.onsuccess = () =>
          {
            const item_o = getRequest.result
            item_o[property] = value
            const putRequest = store.put( item_o, key )

            putRequest.onsuccess = resolve
            
            putRequest.onerror = reject
          }
          getRequest.onerror = reject
        })
      })
  }

  deleteAll ( callback_f )
  {
    return this.ready
      .then( () => 
      {
        return new Promise( ( resolve, reject ) =>
        {
          const mode = 'readwrite'
          const store = this.idb.transaction( [ this.store ], mode ).objectStore( this.store )
          const request = store.openCursor()

          request.onsuccess = req_e =>
          {
            let cursor = req_e.target.result
            let item_o
            if ( cursor )
            {
              item_o = cursor.value
              if ( callback_f( item_o ) ) store.delete( cursor.key )
              cursor.continue()
            }
            else resolve
          }
  
          request.onerror = reject
        })
      })
  }

  delete ( key )
  {
    return this.ready
      .then( () =>
      {
        return new Promise( ( resolve, reject ) =>
        {
          const mode = 'readwrite'
          const request = this.idb.transaction( [ this.store ], mode ).objectStore( this.store )
            .delete( key )

          request.onsuccess = resolve    //: nothing to do

          request.onerror = reject
        })
      })
  }

  clear ()
  {
    return this.ready
      .then( () =>
      {
        return new Promise( ( resolve, reject ) =>
        {
          const mode = 'readwrite'
          const request = this.idb.transaction( [ this.store ], mode ).objectStore( this.store )
            .clear()

          request.onsuccess = resolve    //: nothing to do

          request.onerror = reject
        })
      })
  }

  deleteIDB ()
  {
    window.indexedDB.deleteDatabase( this.idb_s )
  }
}
// ;LOG ( `main.js` )

// : FAST array "functions" (some to inline)
// : a_push : myArray[myArray.length] = _value_
// : a_pop  : var last = myArray[myArray.length--]
// ?? A_shift : original function is best

const A_unshift = ( _a, item ) =>
{
  let len = _a.length
  while ( len )
  {
    _a[len] = _a[len-1]
    --len
  }
  _a[0] = item
}

const A_splice = ( _a, index ) =>
{
  let len = _a.length
  if ( !len ) return
  while ( index < len )
  { 
    _a[index] = _a[index+1]
    ++index
  }
  --_a.length
}

const A_indexOf = ( _a, item ) =>
{
  for ( let at = 0, len = _a.length; at != len ; at++) if (_a[at] === item) return at
  return -1
}

const A_lastIndexOf = (_a, item) =>
{
  let at = _a.length
  while ( at-- ) if ( _a[at] === item ) break
  return at
}

/**
 * A_fill ( capacity_n, any_n )
 * @param {UInt32} capacity 
 * @param {Int32}  any_n 
 */
const A_fill = ( capacity_n, any_n ) =>
{
  const fill_a = new Array( capacity_n )
  while ( --capacity_n >= 0 ) fill_a[ capacity_n ] = any_n
  return fill_a;
}

const dateAsLocale = ( date_d=null ) =>
{
  let rawNow = !date_d ? new Date() : new Date( date_d )
  const yearNow = rawNow.getFullYear()
  const rawMonth = rawNow.getMonth() + 1
  const monthNow = ( rawMonth < 10 ) ? `0${rawMonth}` : `${rawMonth}`
  const rawDay = rawNow.getDate()
  const dayNow = ( rawDay < 10 ) ? `0${rawDay}` : `${rawDay}`
  const now_s = `${yearNow}-${monthNow}-${dayNow}`
  const locale_s = rawNow.toLocaleDateString( 'fr-FR', { year: 'numeric', month: 'long', day: 'numeric' } )    //;console.log( `date: ${dateNow} -- ${today}` )
  return { now_s: now_s, locale_s: locale_s }
}

//========================================================= hash.js
const cyrb53 = ( str, seed = 0 ) =>
{
  let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed
  for ( let i = 0, ch; i < str.length; ++i )
  {
    ch = str.charCodeAt(i)
    h1 = Math.imul(h1 ^ ch, 2654435761)
    h2 = Math.imul(h2 ^ ch, 1597334677)
  }
  h1 = Math.imul(h1 ^ h1>>>16, 2246822507) ^ Math.imul(h2 ^ h2>>>13, 3266489909)
  h2 = Math.imul(h2 ^ h2>>>16, 2246822507) ^ Math.imul(h1 ^ h1>>>13, 3266489909)
  return 4294967296 * (2097151 & h2) + (h1>>>0)
}

//========================================================= styles.js
const DOM_setRootVar = ( varName, value ) =>
{
  document.documentElement.style.setProperty( varName, value )
}

const DOM_getRootVar = ( varName ) =>
{
  return getComputedStyle( document.documentElement ).getPropertyValue( varName ) || ''
}

const DOM_resetNode = ( nodeId ) =>
{
  const node = document.getElementById( nodeId )
  while ( node.firstChild ) node.removeChild( node.firstChild )
}

const DOM_getStyle = ( elementId, property ) =>
{
  let style_e = document.getElementById( elementId )
  return ( style_e ) ? window.getComputedStyle( style_e ).getPropertyValue( property ) : ''
}

const DOM_getImgDim = ( ID ) =>
{
  const img_e = document.getElementById( ID )
  return { width: img_e.getAttribute( 'data-src-width' ), height: img_e.getAttribute( 'data-src-height' ) }
}

const DOM_strimHTML = ( string_s ) =>
{
  return string_s.replace( /(<([^>]+)>)/ig, '' )
}

const DOM_openFolder = ( fold_e ) =>
{
  fold_e.nextElementSibling.classList.toggle( 'ca_is_open' )
  fold_e.parentElement.classList.toggle( 'ca_has_open' )
}

const DOM_openFolderAll = () =>
{
  const opener_e = document.getElementById( 'ca_folder_opener' )
  const is_opened = opener_e.classList.contains( '_ca_folder_opener_' )  //: a class only for toggling
  opener_e.classList.toggle( '_ca_folder_opener_' )

  const folder_a = document.getElementById( 'ca_folder_container_inner' ).querySelectorAll( '.ca_fold_content' )
  let foldItem_a
  for ( let fold_e of folder_a )
  {
    if ( is_opened )
    {
      fold_e.classList.remove( 'ca_has_open' )
      foldItem_a = fold_e.querySelectorAll( '.ca_fold_content_item' )
      for ( let foldItem_e of foldItem_a ) foldItem_e.classList.remove( 'ca_is_open' )
      continue
    }
    fold_e.classList.add( 'ca_has_open' )
    foldItem_a = fold_e.querySelectorAll( '.ca_fold_content_item' )
    for ( let foldItem_e of foldItem_a ) foldItem_e.classList.add( 'ca_is_open' )
  }
}

/**
 * 
 * @param {*} dialog_o: { header: '', content: '', mark: '', options_a: [ 'option_x', ] }
 */
const DOM_dialog = ( dialog_o, noDialog ) =>
{
  const type = dialog_o.type
  dialog_e = document.getElementById( `ca_dialog_is_${type}` )
  if ( noDialog || ( typeof dialog_e.showModal !== 'function' ) )
  {
    const mark_s = dialog_o.mark ? DOM_strimHTML( dialog_o.mark ) : ''
    window.alert( `${dialog_o.header || ''}: ${dialog_o.content || ''} (${mark_s})` )
    return
  }
  //: modal dialog
  if ( dialog_o.header ) document.getElementById( `ca_dialog_header_is_${type}` ).innerHTML = dialog_o.header
  if ( dialog_o.content ) document.getElementById( `ca_dialog_content_is_${type}` )
      .innerHTML = dialog_o.content + ( ( dialog_o.mark ) ? dialog_o.mark : '' )
  if ( dialog_o.options_a === undefined )
  {
    const opt_e = document.getElementById( `ca_dialog_options_is_${type}` )
    if ( opt_e ) opt_e.classList.add( 'ca_dialog_option_hidden' )
  }
  else
  {
    options_e = document.getElementById( `ca_dialog_options_is_${type}` )
    options_e.classList.remove( 'ca_dialog_option_hidden' )
    const options_a = options_e.querySelectorAll( 'li' )
    for ( let at = 0; at < options_a.length; ++at )
    {
      const isHidden = options_a[at].classList.contains( 'ca_dialog_option_hidden' )
      if ( dialog_o.options_a[at] )
      {
        options_a[at].innerHTML = dialog_o.options_a[at]
        options_a[at].classList.remove( 'ca_dialog_option_hidden' )
        options_a[at].addEventListener('click', () =>
        {
          dialog_o.result = options_a[at].id    // ;console.log( `[DOM_dialog] dialog_o.result: ${dialog_o.result}` )
          if ( dialog_o.callback_f ) dialog_o.callback_f( dialog_o.result )
          dialog_e.close( dialog_o.result )
        } )
      }
      else if ( !isHidden ) options_a[at].classList.add( 'ca_dialog_option_hidden' )
    }
  }
  const cancel_s = dialog_o.cancel || 'cancelled'
  document.getElementById( `ca_dialog_close_is_${type}` )
    .addEventListener('click', () => { console.log( `type: ${dialog_o.type}` ) ;dialog_e.close( cancel_s ) } )
  dialog_e.addEventListener('click', ( event ) => { if ( event.target === dialog_e ) dialog_e.close( cancel_s ) })
  dialog_e.addEventListener('close', ( event ) => { dialog_o.result = dialog_e.returnValue } )
  dialog_e.showModal()
}

const DOM_toClipboard = ( clip_o ) =>
{
  const noClipboard = () =>
  {
    clip_o.mark += ` impossible`
    DOM_dialog( clip_o, true )
  }
  const updateClipboard = () =>
  {
    navigator.clipboard.writeText( clip_o.content )
      .then( () => { DOM_dialog( clip_o ) },
             () => { noClipboard() } )
  }

  navigator.permissions.query( { name: "clipboard-write" } )
    .then( ( result ) => { if (result.state == "granted" || result.state == "prompt") updateClipboard() })
    .catch( () => { noClipboard() } )
}

const mailToClipDialog = () =>
{
  const getAddress = ( name, dom ) =>
  {
    const rot13 = ( c ) => { return String.fromCharCode( ( c <= 'Z' ? 90 :122 ) >= ( c = c.charCodeAt(0) + 13 ) ? c : c-26 ) }
    const ident_s = name.replace( /[a-zA-Z]/g, rot13 )
    const dom_s  = dom.replace( /[a-zA-Z]/g, rot13 )
    return `${ident_s}@${dom_s}`
  }

  const dialog_o =
  {
    type: 'note',
    header: 'Adresse pour me contacter',
    content: getAddress( 'nqhcva', 'purepurheq.neg' ),        //: adupin@chercheurd.art
    mark: `<p><mark>copie dans le presse-papier</mark></p>`,
  }
  DOM_toClipboard( dialog_o, DOM_dialog )
}

/*
const menuTechDialog =  () =>
{
  const dialog_o =
  {
    type: 'menu_tech',
    header: 'Technologies Web',
    content: `Chercheurd.art s'appuie sur les technologies du Web les plus récentes, notamment pour le traitement des images numériques haute-définiition.
    Afin d'en apprécier tous les aspects, je vous recommande d'utiliser en priorité les versions les plus récentes des navigateurs Chrome ou Firefox.`,
    cancel: `Merci de votre visite`
  }
  DOM_dialog( dialog_o )
}
*/

const confirmDialog =  ( confirm_s, callback_f ) =>
{
  const dialog_o =
  {
    type: 'confirm',
    content: confirm_s,
    options_a: [ 'Je renonce', 'Je confirme' ],
    callback_f: callback_f,
  }
  DOM_dialog( dialog_o )
}

const statusDialog =  () =>
{
  const dialog_o =
  {
    type: 'status',
  }
  DOM_dialog( dialog_o )
}

const searchTagsDialog =  () =>
{
  const dialog_o =
  {
    type: 'search',
  }
  DOM_dialog( dialog_o )
}

const contextDialog =  ( context_s ) =>
{
  const dialog_o =
  {
    type: context_s,
  }
  if ( context_s === 'user_file' )
  {
    dialog_o.options_a =  [ 'Abandonner', 'Analyser' ]
    dialog_o.callback_f = userImgFileToIDB
  }
  if ( context_s === 'user_file_modify' )
  {
    dialog_o.options_a =  [ 'Abandonner', 'Modifier' ]
    dialog_o.callback_f = userGalleryItemUpdate
  }
  DOM_dialog( dialog_o )
}

//========================================================= drag.js

class DragElement
{
  constructor ( drag_e, keep_b )
  {
    this.gapX = 0
    this.gapY = 0
    this.offsetX = 0
    this.offsetY = 0
    this.atX = 0
    this.atY = 0
    this.drag_e = drag_e
    this.keep_b = keep_b || false
    this.start()
  }

  start ()
  {
    this.drag_e.onmousedown = ( mouse_e ) =>
    {
      this.loose = false
      this.gapX = mouse_e.clientX - this.offsetX
      this.gapY = mouse_e.clientY - this.offsetY
      this.drag_e.addEventListener('mousemove', this, false)
      this.drag_e.addEventListener('mouseup',   this, false)
      return false
    }
  }

  disable ()
  {
    this.loose = true
  }

  handleEvent ( mouse_e )
  {
    if ( this.loose ) return false
    if ( mouse_e.type === 'mousemove' )
    {
      this.atX = mouse_e.clientX - this.gapX
      this.atY = mouse_e.clientY - this.gapY
      this.offsetX = this.atX
      this.offsetY = this.atY
      this.drag_e.style.transform = `translate3d(${this.atX}px, ${this.atY}px, 0)`
      return false
    }
    if ( mouse_e.type === 'mouseup' )
    {
      if ( !this.keep_b )
      {
        this.drag_e.removeEventListener('mousemove', this, true)
        this.drag_e.removeEventListener('mouseup',   this, true)
      }
      this.loose = true
      //return false
    }
  }
}

//========================================================= rgb_hsl.js

/**
 * 
 * @param {Uint8} r : red   color component
 * @param {Uint8} g : green color component
 * @param {Uint8} b : blue  color component
 * 
 * return hue in range [0..359]
 */
const RGB_H = ( r, g, b ) =>
{
  const min = Math.min( r, g, b )
  const max = Math.max( r, g, b )
  if ( max === min ) return 0 // achromatic
  const max_min = max - min
  const h = ( max === r ) ? ( (g - b) / max_min ) + ( g < b ? 6 : 0 ) :
          ( max === g ) ? ( (b - r) / max_min ) + 2 :
                          ( (r - g) / max_min ) + 4
return Math.floor( h * 60 )
}

/**
 * return saturation in range [0..1]
 */
const RGB_S = ( r, g, b ) =>
{
  const min = Math.min( r, g, b )
  const max = Math.max( r, g, b )
  const max_min = max - min
  if ( !max_min ) return 0 // achromatic
  const min_max = min + max
  return ( min_max > 255 ) ? max_min / ( 510 - max - min ) : max_min / min_max
}

/**
 * return luminosity in range [0..1]
 */
const RGB_L = ( r, g, b ) =>
{
  return ( Math.min( r, g, b ) + Math.max( r, g, b ) )  / 510
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/**
 * 
 * @param {*} h  range [0..359]
 * @param {*} s  range [0..1]
 * @param {*} l  range [0..1]
 * 
 * return [r,g,b] range [0..1]
 */
const HSL_RGB = ( h, s, l ) =>
{
  let r, g, b

  if (s === 0) r = g = b = l // achromatic
  else
  {
    const H2R = ( p, q, t ) => // hsl to rgb
    {
      if ( t < 0 ) t += 1
      if ( t > 1 ) t -= 1
      if ( t < 0.1666667 ) return p + (q - p) * 6 * t  // 1/6
      if ( t < 0.5 ) return q
      if ( t < 0.6666667 ) return p + (q - p) * (0.6666667 - t) * 6
      return p
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s
    const p = 2 * l - q
    h /= 360
    r = H2R( p, q, h + 0.3333334 )
    g = H2R( p, q, h )
    b = H2R( p, q, h - 0.3333334 )
  }
  return [ r, g, b ]
}

const H_toMatrix = ( hue ) =>
{
  const GRAY_DELTA = 0.5
  let red_s, green_s, blue_s
  let matrix_s = DOM_getRootVar( '--M3_FE_MATRIX' )
  if ( hue < 0 ) red_s = green_s = blue_s = DOM_getRootVar( '--M3_FE_MATRIX_GRAY_VALUE' )
  else
  {
    rgb_a   = HSL_RGB( hue, 1, 0.5 )  // normalized HSL
    // ~ rgb_a   = HSL_RGB( hue, 100, 50 )  // normalized HSL
    red_s   = rgb_a[0] + GRAY_DELTA
    green_s = rgb_a[1] + GRAY_DELTA
    blue_s  = rgb_a[2] + GRAY_DELTA
  }
  matrix_s = matrix_s
    .replace( 'R', red_s )
    .replace( 'G', green_s )
    .replace( 'B', blue_s )
  return matrix_s
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//========================================================= colorMatrix.js

class DOM_FeColorMatrix
{
  constructor ( filterID, animateID, animate_a )
  {
    this._animateID = animateID || 'ca_animate'
    this._filter_e = document.getElementById( filterID )
    this.createMatrix( animate_a )
  }

  toMatrix ( rgb_o )
  {
    const from_s = `${rgb_o.r0} 0 0 0 0    0 ${rgb_o.g0} 0 0 0    0 0 ${rgb_o.b0} 0 0    0 0 0 1 0`
    const to_s   = `${rgb_o.r1} 0 0 0 0    0 ${rgb_o.g1} 0 0 0    0 0 ${rgb_o.b1} 0 0    0 0 0 1 0`
    return { from_s: from_s, to_s: to_s }
  }
  
  toBegin ( previousID, delay )
  {
    let begin_s = ( delay !== undefined ) ? `${delay}s;` : ``
    if ( previousID !== undefined ) begin_s += `${previousID}.end`
    return begin_s
  }
  
  toDuration ( dur_o )
  {
    return `${dur_o.d}s`
  }
  
  createAnimate ( index, anim_a )
  {
    const anim_e = document.createElementNS('http://www.w3.org/2000/svg', 'animate')
    anim_e.setAttribute( 'id', `${this._animateID}_${index}` )
    anim_e.setAttribute( 'attributeType', 'XML' )
    anim_e.setAttribute( 'attributeName', 'values' )
    anim_e.setAttribute( 'dur', this.toDuration( anim_a ) )
    anim_e.setAttribute( 'repeatCount', 1 )
    let from_s, to_s
    ( {from_s, to_s } = this.toMatrix( anim_a ) )
    anim_e.setAttribute( 'from', from_s )
    anim_e.setAttribute( 'to', to_s )
    return anim_e
  }
  
  createMatrix ( animate_a )
  {
    const lastIndex = animate_a.length - 1
    for (let at = 0; at <= lastIndex; ++at )
    {
      const animate_e = this.createAnimate( at, animate_a[at])
      const begin_s = ( at === 0 ) ? this.toBegin( `${this._animateID}_${lastIndex}`, 0 ) : this.toBegin( `${this._animateID}_${at - 1}` )
      animate_e.setAttribute( 'begin', begin_s )
      this._filter_e.appendChild( animate_e )
    }
  }
}

//========================================================= LogScale.js
/**
 * Logarithmic scale
 * @param {*} scale_o : { minpos: _n, maxpos: _n, minval: _n, maxval: _n }
 */
class LogScale
{
  constructor ( scale_o )
  {
    // ?? this.maxpos = scale_o.maxpos || 100
    this.minpos = scale_o.minpos || 0
    this.minlval = Math.log( scale_o.minval || 1 )
    this.maxlval = Math.log( scale_o.maxval || 100000 )
    this.scale = ( this.maxlval - this.minlval ) / ( scale_o.maxpos - this.minpos )
  }

  getPosition ( value_n )
  {
    return this.minpos + (( Math.log( value_n ) - this.minlval ) / this.scale )
  }

  //  ?? NOT USED
  //  ?? getValue ( position_n )
  //  ?? {
  //  ??   return Math.exp( (position - this.minpos) * this.scale + this.minlval )
  //  ?? }
  
}

//========================================================= areas.js
const AreaActive = ID_s => document.getElementById( `ca_area_${ID_s}` )

const AreaToggle = ( fromID_s, toID_s ) =>
{
  AreaActive( fromID_s ).classList.toggle( 'ca_area_active' )
  AreaActive( toID_s ).classList.toggle( 'ca_area_active' )
}

const AreaSwitch = ( fromID_s ) =>
{
  const isPerpective_b = document.querySelector( `.ca_area_perspective` ) !== null
  document.getElementById( 'ca_content' ).classList.toggle( 'ca_content_perspective' )
  const areas = document.getElementsByClassName( 'ca_area' )
  const selectors = document.getElementsByClassName( 'ca_area_selector' )
  const length = selectors.length
  for (let at= 0; at < length; ++at)
  {
    areas.item( at ).classList.toggle( `ca_area_perspective` )
    selectors.item( at ).classList.toggle( 'ca_selector_perspective' )
  }
  if ( isPerpective_b ) document.getElementById( fromID_s.replace( 'select_', '') ).classList.toggle( 'ca_area_active' )
  else document.querySelector( `.ca_area_active` ).classList.toggle( 'ca_area_active' )
}

//========================================================= scrollbar.js

const ScrollLevel = ( percent ) =>
{
                                        //console.log`percent: ${percent}`
  document.getElementById( 'ca_grad_down_empty' )
   .setAttribute('offset', `${percent}%` )
  document.getElementById( 'ca_grad_down_fill' )
  .setAttribute('offset', `${percent}%` )

  percent = 100 - percent
  document.getElementById( 'ca_grad_up_empty' )
    .setAttribute('offset', `${percent}%` )
  document.getElementById( 'ca_grad_up_fill' )
   .setAttribute('offset', `${percent}%` )
}

const ScrollPosition = ( position ) =>
{
  //const height = (document.body.clientHeight - window.innerHeight) || 1 // avoid div by 0
  const height = (document.body.scrollHeight - window.innerHeight) || 1 // avoid div by 0
                                               //console.log`clientHeight: ${document.body.clientHeight}`
                                               //console.log`scrollHeight: ${document.body.scrollHeight}`
                                               //console.log`innerHeight: ${window.innerHeight}`
                                               //console.log`height: ${height}`
  //const percent = Math.floor( position / height * 100.0 )
  //ScrollLevel( percent )
  ScrollLevel( Math.floor( position / height * 100.0 ) )
}

const ScrollPage = ( factor ) =>
{
  const scroll_o =
  {
    left: 0,
    top:  window.innerHeight * factor,
    behavior: 'smooth'
  }
  window.scrollBy( scroll_o );
  ScrollPosition( window.pageYOffset )
}
window.addEventListener('scroll', (e) => { ScrollPosition( window.pageYOffset ) })  // : HTML page init must be just before </body>

//========================================================= Search.js
//: fromClient --> provider ===================
//: const client_o =
//: {
//:   task_s: 'SEARCH',
//:   need_s: need_s,
//:   tag_s: CA_search.tags[CA_search.tag_n],
//: }
//: client_p.postMessage( task_o )

const CA_search =
{
  port_o: null,
  tags:
  [
    'ORD',
    'PER',
    'ART',
    'WORK',
    'COL',
    'BIB',
    'WEB',
    'LOC',
    'DATE',
  ],
  titles:
  [
    `INDÉFINI`,
    `NOM DE PERSONNE`,
    `NOM D'ARTISTE`,
    `ŒUVRE D'ART`,
    `COLLECTION`,
    `BIBLIOGRAPHIE`,
    `TECHNOLOGIE`,
    `LOCALISATION`,
    'DATE',
  ],
  need_s: '',
  tag_n:  0,
  tag_s:  '',
}

//: fromProvider --> client ===================
const fromProvider = ( provider_o ) =>
{
  const found_a = provider_o.result
  searchOutputEntries( !found_a ? 'RESET' : found_a.length ? found_a : 'NOT_FOUND' )    //: null for RESET
  if ( provider_o.task_s === 'RETRIEVE' )
  {
    CA_search.need_s = found_a[0].need_s
    CA_search.tag_s  = found_a[0].tag_s
    searchUpdateRequest()
  }
}

// ================== INIT WORKER ======================
( () =>
  {
    const provider_i = new SharedWorker( `${SITE_ROOT_URL}static/scripts/search_w.js` )
    CA_search.port_o = provider_i.port
    CA_search.port_o.onmessageerror = err_e => console.log( `CLIENT ERROR: ${err_e.message}` )
    CA_search.port_o.onmessage = provider_e => { fromProvider( provider_e.data ) }
    CA_search.port_o.start()
    CA_search.port_o.postMessage( { task_s: 'INIT', url_s: `${SITE_ROOT_URL}search.ini`, } )
    CA_search.port_o.postMessage( { task_s: 'RETRIEVE' } )
  }
)()

// ===================== OUTPUT ======================
const searchOutputEntries = ( entries_ ) =>
{
  const output_e = document.getElementById('ca_search_list')
  while ( output_e.firstChild ) output_e.removeChild( output_e.firstChild )    //: cleaning
  let template_e, clone_e, result_e, result_s
  if ( typeof entries_ === 'string' )
  {
    if ( entries_ === 'RESET' ) return
    template_e = document.getElementById('ca_search_result_entry_void')
    clone_e = document.importNode( template_e.content, true )
    result_e = clone_e.querySelectorAll( 'dt' )
    result_s = ( entries_ === 'NOT_FOUND' ) ?
      `Auncun résultat n'a été trouvé. Essayez avec un autre filtre.`    //: 'NOT_FOUND'
    : `Le terme fourni pour la recherche est invalide!`                  //: 'BAD_ENTRY'
    result_e[0].textContent = result_s
    output_e.appendChild( clone_e )
    return
  }
  //: matches
  template_e = document.getElementById('ca_search_result_entry')
  let div_e, dl_e, dt_e, a_e, dd_e, em_e
  let ate = -1    //: loop iterator
  for ( entry_o in entries_ )    //:  entries_ is Array
  {
    ++ate
    clone_e = document.importNode( template_e.content, true )

    div_e = clone_e.querySelectorAll( 'div.ca_urlentry' )    //: <div class="ca_urlentry">
    if ( entries_[entry_o].visited ) div_e[0].classList.toggle( 'ca_urlentry_mark' )
    dl_e = clone_e.querySelectorAll( 'dl' )
    
    a_e = clone_e.querySelectorAll( 'a' )                  //: <a href="...">_LINK_
    a_e[0].setAttribute( 'href', `${SITE_ROOT_URL}${entries_[entry_o].path_s}.html` )
    a_e[0].setAttribute( 'data-entry', `${ate}` )
    a_e[0].setAttribute( 'onclick', 'searchVisit( this )' )
    a_e[0].textContent = entries_[entry_o].title_s
    dt_e = clone_e.querySelectorAll( 'dt' )                //: <dt>_TITLE_
    dt_e[0].appendChild( a_e[0] )
    dl_e[0].appendChild( dt_e[0] )

    dd_e = clone_e.querySelectorAll( 'dd' )                //: <dd>_DATE_
    dd_e[0].textContent = entries_[entry_o].date_s + ' '
    em_e = document.createElement( 'em' )                 //: <em>_AUTHOR_
    em_e.textContent = entries_[entry_o].author_s
    dd_e[0].appendChild( em_e )
    dl_e[0].appendChild( dd_e[0] )

    dd_e[1].textContent = entries_[entry_o].abstract_s    //: <dd>_ABSTRACT_
    dl_e[0].appendChild( dd_e[1] )

    div_e[0].appendChild( dl_e[0] )
    output_e.appendChild( div_e[0] )
  }
}

const searchUpdateRequest = () =>
{
  searchSetMarks()
  searchSetNeedForm()
  const at = CA_search.tags.findIndex( atag => atag === CA_search.tag_s )
  searchSetTagForm( at )
}

const searchSetNeedForm = ( need_s ) => document.getElementById( 'ca_form_input_search_needle' ).value = CA_search.need_s

const searchSetTagForm = ( tag_n ) => document.getElementById( 'ca_form_input_search_tag' ).innerHTML = CA_search.titles[tag_n]

const searchSetTag = ( tag_n ) =>
{
  CA_search.tag_n = tag_n
  searchSetTagForm( tag_n )
}

const searchSubmit = () =>
{
  const input_s = document.getElementById( 'ca_form_input_search_needle' ).value
  const need_s = input_s.replace( /[^a-zA_Z\d\s&'\-]/gi, '' )    //: sanitize
  if ( need_s.length === 0 ) return searchOutputEntries( 'BAD_ENTRY' )    //: return is undefined
  const tag_s = CA_search.tags[CA_search.tag_n]
  CA_search.port_o.postMessage( { task_s: 'SEARCH', need_s: need_s, tag_s: tag_s } )
}

const searchVisit = ( entry_e ) =>
{
  CA_search.port_o.postMessage( { task_s: 'VISIT_URL', entry: entry_e.getAttribute( 'data-entry' ) } )
  let parent_e = entry_e.parentNode
  while ( parent_e )    //: find div ancestor with class ca_urlentry
  {
    if ( parent_e.classList.contains( 'ca_urlentry' ) ) break
    parent_e = parent_e.parentNode
  }
  parent_e.classList.toggle( 'ca_urlentry_mark' )
}

const searchReset = () =>
{
  searchSetMarks()
  searchOutputEntries( 'RESET' )
  CA_search.need_s = ''
  CA_search.tag_s  = ''
  CA_search.port_o.postMessage( { task_s: 'RESET' } )
}

const searchPrevious = () => CA_search.port_o.postMessage( { task_s: 'PREVIOUS' } )

const searchNext = () => CA_search.port_o.postMessage( { task_s: 'NEXT' } )

const searchSetMarks = () =>
{
  const need_s = CA_search.need_s
  document.querySelectorAll( `mark[data-tag="${CA_search.tag_s}"]` )
    .forEach( ( item_e ) =>
    {
      if ( item_e.innerText.indexOf( need_s ) > -1 ) item_e.classList.toggle( 'ca_searchentry_mark' )
    })
}



